{"version":3,"sources":["../node_modules/shortid/lib/alphabet.js","../node_modules/shortid/index.js","../node_modules/shortid/lib/index.js","../node_modules/shortid/lib/random/random-from-seed.js","../node_modules/shortid/lib/build.js","../node_modules/shortid/lib/generate.js","../node_modules/shortid/lib/random/random-byte-browser.js","../node_modules/nanoid/format.browser.js","../node_modules/shortid/lib/is-valid.js","../node_modules/shortid/lib/util/cluster-worker-id-browser.js","../../../../../src/js/card-number/constants/index.js","../../../../../src/js/card-number/utilities/brandBinMatrix.js","../../../../../src/js/card-number/utilities/acceptedBrandsCheck.js","../../../../../src/js/card-number/utilities/getRawValue.js","../../../../../src/js/card-number/utilities/possibleBrand.js","../../../../../src/js/card-number/utilities/binCheck.js","../../../../../src/js/card-number/utilities/filterAcceptedBrands.js","../../../../../src/js/card-number/utilities/getBrandClassName.js","../../../../../src/js/card-number/utilities/modCheck.js","../../../../../src/js/card-number/utilities/getCardInfo.js","../../../../../src/js/card-number/utilities/getMask.js","../../../../../src/js/card-number/utilities/validator.js","../../../../src/js/card-number/index.js","../../../../src/js/text-mask/conformToMask.js","../../../../src/js/text-mask/adjustCaretPosition.js","../../../../src/js/text-mask/createTextMaskInputElement.js","../../../../src/js/text-mask/utilities.js","../../../../src/js/text-mask/constants.js","../../../../src/js/text-mask/index.js","../node_modules/@babel/runtime/helpers/toConsumableArray.js","../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/iterableToArray.js","../node_modules/@babel/runtime/helpers/nonIterableSpread.js","../../../../../src/js/text-mask/react/useTextMask.js","../../../../../src/js/text-mask/react/index.js"],"names":["alphabet","previousSeed","shuffled","randomFromSeed","require","ORIGINAL","reset","setCharacters","_alphabet_","length","Error","unique","split","filter","item","ind","arr","lastIndexOf","join","getShuffled","characterIndex","sourceArray","targetArray","r","nextValue","Math","floor","push","splice","shuffle","module","exports","get","characters","seed","lookup","index","build","isValid","clusterWorkerId","generate","seedValue","worker","workerId","newCharacters","undefined","_seed_","counter","previousSeconds","str","seconds","Date","now","random","format","number","done","loopCounter","pow","randomByte","crypto","window","msCrypto","getRandomValues","size","Uint8Array","bytes","i","mask","log","LN2","step","id","RegExp","replace","test","COMPONENT_CLASSNAME","COMPONENT_WRAPPER_CLASSNAME","INDICATOR_CLASSNAME","INDICATOR_WRAPPER_CLASSNAME","LENGTH_AMEX","LENGTH_DEFAULT","FIVE_DIGITS","FOUR_DIGITS","SIX_DIGITS","AMEX_MASK","NON_AMEX_MASK","AMEX","DISCOVER","ELECTRON","ELO","INVALID","MASTERCARD","UNKNOWN","VISA","EMPTY","INVALID_BIN","INVALID_BIN_BRAND","INVALID_GENERIC","NOT_SUPPORTED","PARTIAL","ERROR_MAP","empty","invalid_bin","invalid_bin_brand","invalid_generic","not_supported","partial","brands","brandMatrix","binMatrix","fourDigits","ranges","4","max","min","5","6","7","8","twoOrThreeDigits","1","2","3","twoDigits","acceptedBrands","acceptedBrandsLength","isAccepted","cardBrand","brand","value","cardNum","eloBins","possibleBrand","firstDigit","eloOrOther","__checkTwoOrThreeDigits","digits","possibleBins","possibleBinsLength","isValidBin","bin","__getIsValidBin","cardNumLengthOne","cardNumLength","digitsToCheck","cardNumsToValidate","validationNumsLength","validationRange","Number","__isValidMasterCard","isFewerThanFourDigits","__isValidDiscoverCard","getRawValue","getPossibleBrand","brandsLen","unfilteredArr","a","brandIsKnown","prefix","brandName","PRODUCT_ARRAY","mod11","isMod10","l","multiple","sum","parseInt","ccMod10Check","isMod11","len","digit","testDigits","total","temp","myCheck","ccMod11Check","mod10","conditions","cardBins","checkMods","partnerAcceptedBrands","shouldCheckAcceptedBrands","validateMod11","rawValue","maxLength","passesMod","maskedCardNumber","checkMod","isSupportedBrand","acceptedBrandsCheck","binCheck","isSupported","validator","isBlur","checkMod11","isPartialValue","error","emptyArray","conformToMask","config","currentCaretPosition","guide","placeholder","placeholderChars","previousConformedValue","isArray","char","suppressGuide","rawValueLength","previousConformedValueLength","placeholderLength","maskLength","editDistance","isAddition","indexOfFirstChange","rawValueArr","shouldOffset","conformedValue","someCharsRejected","placeholderLoop","charInPlaceholder","rawValueChar","indexOfLastFilledPlaceholderChar","meta","adjustCaretPosition","nonRegexChars","previousPlaceholder","conformedValueLength","editLength","startingSearchIndex","normalizedConformedValue","intersection","normalizedRawValue","targetChar","previousLeftMaskChars","maskLengthChanged","targetIsMaskMovingLeft","trackRightCharacter","countTargetCharInIntersection","requiredNumberOfMatches","numberOfEncounteredMatches","lastPlaceholderChar","createTextMaskInputElement","state","update","inputElement","placeholderChar","upperCaseValue","isHTMLInputElement","inputValue","isNil","cleanMask","cleanedMask","adjustedCaretPosition","inputValueShouldBeEmpty","inputElementValue","safeSetSelection","isAndroid","navigator","defer","requestAnimationFrame","setTimeout","element","selectionPosition","document","Array","maskObj","maskChar","placeChar","placeholderStr","Set","NO_MASK_ERROR","NO_INPUT_ERROR","NO_PLACEHOLDER_CHAR_IN_MASK","arrayWithoutHoles","iterableToArray","nonIterableSpread","arr2","iter","Symbol","iterator","Object","prototype","toString","call","from","TypeError","useTextMask","props","onChange","inputRef","useRef","textMask","useState","setState","createTextMask","newState","e","useEffect","getInputProps","ref"],"mappings":"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","file":"static/js/34.d26a3b9d.chunk.js","sourcesContent":["'use strict';\n\nvar randomFromSeed = require('./random/random-from-seed');\n\nvar ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';\nvar alphabet;\nvar previousSeed;\n\nvar shuffled;\n\nfunction reset() {\n    shuffled = false;\n}\n\nfunction setCharacters(_alphabet_) {\n    if (!_alphabet_) {\n        if (alphabet !== ORIGINAL) {\n            alphabet = ORIGINAL;\n            reset();\n        }\n        return;\n    }\n\n    if (_alphabet_ === alphabet) {\n        return;\n    }\n\n    if (_alphabet_.length !== ORIGINAL.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);\n    }\n\n    var unique = _alphabet_.split('').filter(function(item, ind, arr){\n       return ind !== arr.lastIndexOf(item);\n    });\n\n    if (unique.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));\n    }\n\n    alphabet = _alphabet_;\n    reset();\n}\n\nfunction characters(_alphabet_) {\n    setCharacters(_alphabet_);\n    return alphabet;\n}\n\nfunction setSeed(seed) {\n    randomFromSeed.seed(seed);\n    if (previousSeed !== seed) {\n        reset();\n        previousSeed = seed;\n    }\n}\n\nfunction shuffle() {\n    if (!alphabet) {\n        setCharacters(ORIGINAL);\n    }\n\n    var sourceArray = alphabet.split('');\n    var targetArray = [];\n    var r = randomFromSeed.nextValue();\n    var characterIndex;\n\n    while (sourceArray.length > 0) {\n        r = randomFromSeed.nextValue();\n        characterIndex = Math.floor(r * sourceArray.length);\n        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);\n    }\n    return targetArray.join('');\n}\n\nfunction getShuffled() {\n    if (shuffled) {\n        return shuffled;\n    }\n    shuffled = shuffle();\n    return shuffled;\n}\n\n/**\n * lookup shuffled letter\n * @param index\n * @returns {string}\n */\nfunction lookup(index) {\n    var alphabetShuffled = getShuffled();\n    return alphabetShuffled[index];\n}\n\nfunction get () {\n  return alphabet || ORIGINAL;\n}\n\nmodule.exports = {\n    get: get,\n    characters: characters,\n    seed: setSeed,\n    lookup: lookup,\n    shuffled: getShuffled\n};\n","'use strict';\nmodule.exports = require('./lib/index');\n","'use strict';\n\nvar alphabet = require('./alphabet');\nvar build = require('./build');\nvar isValid = require('./is-valid');\n\n// if you are using cluster or multiple servers use this to make each instance\n// has a unique value for worker\n// Note: I don't know if this is automatically set when using third\n// party cluster solutions such as pm2.\nvar clusterWorkerId = require('./util/cluster-worker-id') || 0;\n\n/**\n * Set the seed.\n * Highly recommended if you don't want people to try to figure out your id schema.\n * exposed as shortid.seed(int)\n * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.\n */\nfunction seed(seedValue) {\n    alphabet.seed(seedValue);\n    return module.exports;\n}\n\n/**\n * Set the cluster worker or machine id\n * exposed as shortid.worker(int)\n * @param workerId worker must be positive integer.  Number less than 16 is recommended.\n * returns shortid module so it can be chained.\n */\nfunction worker(workerId) {\n    clusterWorkerId = workerId;\n    return module.exports;\n}\n\n/**\n *\n * sets new characters to use in the alphabet\n * returns the shuffled alphabet\n */\nfunction characters(newCharacters) {\n    if (newCharacters !== undefined) {\n        alphabet.characters(newCharacters);\n    }\n\n    return alphabet.shuffled();\n}\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction generate() {\n  return build(clusterWorkerId);\n}\n\n// Export all other functions as properties of the generate function\nmodule.exports = generate;\nmodule.exports.generate = generate;\nmodule.exports.seed = seed;\nmodule.exports.worker = worker;\nmodule.exports.characters = characters;\nmodule.exports.isValid = isValid;\n","'use strict';\n\n// Found this seed-based random generator somewhere\n// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)\n\nvar seed = 1;\n\n/**\n * return a random number based on a seed\n * @param seed\n * @returns {number}\n */\nfunction getNextValue() {\n    seed = (seed * 9301 + 49297) % 233280;\n    return seed/(233280.0);\n}\n\nfunction setSeed(_seed_) {\n    seed = _seed_;\n}\n\nmodule.exports = {\n    nextValue: getNextValue,\n    seed: setSeed\n};\n","'use strict';\n\nvar generate = require('./generate');\nvar alphabet = require('./alphabet');\n\n// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.\n// This number should be updated every year or so to keep the generated id short.\n// To regenerate `new Date() - 0` and bump the version. Always bump the version!\nvar REDUCE_TIME = 1567752802062;\n\n// don't change unless we change the algos or REDUCE_TIME\n// must be an integer and less than 16\nvar version = 7;\n\n// Counter is used when shortid is called multiple times in one second.\nvar counter;\n\n// Remember the last time shortid was called in case counter is needed.\nvar previousSeconds;\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction build(clusterWorkerId) {\n    var str = '';\n\n    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);\n\n    if (seconds === previousSeconds) {\n        counter++;\n    } else {\n        counter = 0;\n        previousSeconds = seconds;\n    }\n\n    str = str + generate(version);\n    str = str + generate(clusterWorkerId);\n    if (counter > 0) {\n        str = str + generate(counter);\n    }\n    str = str + generate(seconds);\n    return str;\n}\n\nmodule.exports = build;\n","'use strict';\n\nvar alphabet = require('./alphabet');\nvar random = require('./random/random-byte');\nvar format = require('nanoid/format');\n\nfunction generate(number) {\n    var loopCounter = 0;\n    var done;\n\n    var str = '';\n\n    while (!done) {\n        str = str + format(random, alphabet.get(), 1);\n        done = number < (Math.pow(16, loopCounter + 1 ) );\n        loopCounter++;\n    }\n    return str;\n}\n\nmodule.exports = generate;\n","'use strict';\n\nvar crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto\n\nvar randomByte;\n\nif (!crypto || !crypto.getRandomValues) {\n    randomByte = function(size) {\n        var bytes = [];\n        for (var i = 0; i < size; i++) {\n            bytes.push(Math.floor(Math.random() * 256));\n        }\n        return bytes;\n    };\n} else {\n    randomByte = function(size) {\n        return crypto.getRandomValues(new Uint8Array(size));\n    };\n}\n\nmodule.exports = randomByte;\n","// This file replaces `format.js` in bundlers like webpack or Rollup,\n// according to `browser` config in `package.json`.\n\nmodule.exports = function (random, alphabet, size) {\n  // We canâ€™t use bytes bigger than the alphabet. To make bytes values closer\n  // to the alphabet, we apply bitmask on them. We look for the closest\n  // `2 ** x - 1` number, which will be bigger than alphabet size. If we have\n  // 30 symbols in the alphabet, we will take 31 (00011111).\n  // We do not use faster Math.clz32, because it is not available in browsers.\n  var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1\n  // Bitmask is not a perfect solution (in our example it will pass 31 bytes,\n  // which is bigger than the alphabet). As a result, we will need more bytes,\n  // than ID size, because we will refuse bytes bigger than the alphabet.\n\n  // Every hardware random generator call is costly,\n  // because we need to wait for entropy collection. This is why often it will\n  // be faster to ask for few extra bytes in advance, to avoid additional calls.\n\n  // Here we calculate how many random bytes should we call in advance.\n  // It depends on ID length, mask / alphabet size and magic number 1.6\n  // (which was selected according benchmarks).\n\n  // -~f => Math.ceil(f) if n is float number\n  // -~i => i + 1 if n is integer number\n  var step = -~(1.6 * mask * size / alphabet.length)\n  var id = ''\n\n  while (true) {\n    var bytes = random(step)\n    // Compact alternative for `for (var i = 0; i < step; i++)`\n    var i = step\n    while (i--) {\n      // If random byte is bigger than alphabet even after bitmask,\n      // we refuse it by `|| ''`.\n      id += alphabet[bytes[i] & mask] || ''\n      // More compact than `id.length + 1 === size`\n      if (id.length === +size) return id\n    }\n  }\n}\n","'use strict';\nvar alphabet = require('./alphabet');\n\nfunction isShortId(id) {\n    if (!id || typeof id !== 'string' || id.length < 6 ) {\n        return false;\n    }\n\n    var nonAlphabetic = new RegExp('[^' +\n      alphabet.get().replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&') +\n    ']');\n    return !nonAlphabetic.test(id);\n}\n\nmodule.exports = isShortId;\n","'use strict';\n\nmodule.exports = 0;\n","// Component rendering-related items\nexport const COMPONENT_CLASSNAME = 'vds-input-card';\nexport const COMPONENT_WRAPPER_CLASSNAME = 'vds-cardnumber';\nexport const INDICATOR_CLASSNAME = 'vds-card-indicator';\nexport const INDICATOR_WRAPPER_CLASSNAME = 'vds-input-option';\nexport const LENGTH_AMEX = 17; // 15-digit card number plus 2 masked spaces\nexport const LENGTH_DEFAULT = 19; // 16-digit card number plus 3 masked spaces\nexport const FIVE_DIGITS = [/\\d/, /\\d/, /\\d/, /\\d/, /\\d/];\nexport const FOUR_DIGITS = [/\\d/, /\\d/, /\\d/, /\\d/];\nexport const SIX_DIGITS = [/\\d/, /\\d/, /\\d/, /\\d/, /\\d/, /\\d/];\nexport const AMEX_MASK = [...FOUR_DIGITS, ' ', ...SIX_DIGITS, ' ', ...FIVE_DIGITS];\nexport const NON_AMEX_MASK = [\n  ...FOUR_DIGITS,\n  ' ',\n  ...FOUR_DIGITS,\n  ' ',\n  ...FOUR_DIGITS,\n  ' ',\n  ...FOUR_DIGITS\n];\n\n/**\n * Card Brands\n *\n * All brands are used for when there is at least one digit entered by the user\n *\n */\nexport const AMEX = 'AMEX';\nexport const DISCOVER = 'DISCOVER';\nexport const ELECTRON = 'ELECTRON';\nexport const ELO = 'ELO';\nexport const INVALID = 'INVALID';\nexport const MASTERCARD = 'MASTERCARD';\nexport const UNKNOWN = 'UNKNOWN';\nexport const VISA = 'VISA';\n\n// Card Validation Errors\nexport const EMPTY = 'EMPTY';\nexport const INVALID_BIN = 'INVALID_BIN';\nexport const INVALID_BIN_BRAND = 'INVALID_BIN_BRAND';\nexport const INVALID_GENERIC = 'INVALID_GENERIC';\nexport const NOT_SUPPORTED = 'NOT_SUPPORTED';\nexport const PARTIAL = 'PARTIAL';\n\n// These errors are all triggered onChange except where noted\nexport const ERROR_MAP = {\n  empty: EMPTY, // field is empty\n  invalid_bin: INVALID_BIN, // first digit does not map to a known card brand\n  invalid_bin_brand: INVALID_BIN_BRAND, // brand is recognized but bin range is not valid\n  invalid_generic: INVALID_GENERIC, // card number is invalid for some other reason not specified\n  not_supported: NOT_SUPPORTED, // brand is recognized but not supported by merchant / partner\n  partial: PARTIAL // partial value, triggered only onBlur\n};\n","import { AMEX, DISCOVER, ELO, MASTERCARD, VISA } from '../constants';\n\nexport const brands = [AMEX, DISCOVER, ELO, MASTERCARD, VISA];\n\n/**\n  * If the value's first digit does not map to one of these it will cause the\n  `possibleBrand` to be `INVALID` and the validator to return `invalid_bin`.\n  */\nexport const brandMatrix = {\n  '2': MASTERCARD,\n  '3': AMEX,\n  '4': VISA,\n  '5': MASTERCARD,\n  '6': DISCOVER\n};\n\n/**\n  * If the value's first digit maps to one of the `brandMatrix` brands but the rest of the\n  value, aka 'bin,' does not follow the below logic, it will cause the `possibleBrand` to be\n  one of the known brands in `brandMatrix` and the validator to return `invalid_bin_brand`.\n  */\nexport const binMatrix = {\n  AMEX: ['34', '37'],\n  DISCOVER: {\n    fourDigits: ['6011'],\n    ranges: {\n      4: {\n        max: 6229,\n        min: 6221\n      },\n      5: {\n        max: 62292,\n        min: 62212\n      },\n      6: {\n        max: 622925,\n        min: 622126\n      },\n      7: {\n        max: 6229259,\n        min: 6221260\n      },\n      8: {\n        max: 62292599,\n        min: 62212600\n      }\n    },\n    twoOrThreeDigits: ['60', '62', '65', '601', '622']\n  },\n  MASTERCARD: {\n    ranges: {\n      1: {\n        max: 2,\n        min: 2\n      },\n      2: {\n        max: 27,\n        min: 22\n      },\n      3: {\n        max: 272,\n        min: 222\n      },\n      4: {\n        max: 2720,\n        min: 2221\n      },\n      5: {\n        max: 27209,\n        min: 22210\n      },\n      6: {\n        max: 272099,\n        min: 222100\n      }\n    },\n    twoDigits: ['51', '52', '53', '54', '55']\n  },\n  VISA: ['4']\n};\n","import { brands } from './brandBinMatrix';\nimport { UNKNOWN } from '../constants';\n\n/**\n * @description check user-entered cardBrand against merchant- and partner-supported brands.\n * Call function only if shouldValidateAcceptedCards prop is true in your component.\n *\n * @param {string} cardBrand\n * @param {array} acceptedBrands defaults to all brands\n * @return {bool}\n */\nexport default (cardBrand, acceptedBrands = brands) => {\n  const acceptedBrandsLength = acceptedBrands.length;\n  let isAccepted = false;\n  if (cardBrand === UNKNOWN) {\n    return true;\n  }\n\n  for (let brand = 0; brand < acceptedBrandsLength; brand++) {\n    if (acceptedBrands[brand] === cardBrand) {\n      isAccepted = true;\n      break;\n    }\n  }\n\n  return isAccepted;\n};\n","export default value => value.toString().replace(/\\s+/g, '');\n","/* eslint-disable spellcheck/spell-checker */\nimport { brandMatrix } from './brandBinMatrix';\nimport { ELO, INVALID, UNKNOWN } from '../constants';\n\n/**\n * @description Checks if the entered card number is for an Elo bin\n *\n * @param {string} cardNum\n * @param {string} cardBrand\n * @param {array} eloBins\n * @returns {string}\n */\nexport const eloOrOther = (cardNum, cardBrand, eloBins) => {\n  if (eloBins && eloBins.length > 0) {\n    for (let i = 0; i < eloBins.length; i++) {\n      if (cardNum.indexOf(eloBins[i].toString()) === 0) {\n        // cardNum starts with an Elo prefix and is definitely Elo\n        return ELO;\n      } else if (eloBins[i].toString().indexOf(cardNum) === 0) {\n        // cardNum is part of an Elo prefix but not confirmed Elo\n        return UNKNOWN;\n      }\n    }\n  }\n  return cardBrand;\n};\n\n/**\n * @description Checks what is the cardBrand based on provided value\n *\n * @param {string} cardNum\n * @param {array} eloBins\n * @returns {string}\n */\nconst getPossibleBrand = (cardNum, eloBins) => {\n  let possibleBrand = UNKNOWN;\n  if (!cardNum.length) {\n    return possibleBrand;\n  }\n  const firstDigit = cardNum[0];\n  possibleBrand = brandMatrix[firstDigit] || INVALID;\n  possibleBrand = possibleBrand === INVALID ? INVALID : eloOrOther(cardNum, possibleBrand, eloBins);\n\n  return possibleBrand;\n};\n\nexport default getPossibleBrand;\n","/* eslint-disable spellcheck/spell-checker */\nimport { binMatrix } from './brandBinMatrix';\nimport getRawValue from './getRawValue';\nimport getPossibleBrand from './possibleBrand.js';\nimport { AMEX, DISCOVER, ELO, INVALID, MASTERCARD, UNKNOWN, VISA } from '../constants';\n\n/**\n * @description execute for loop for common use cases to determine if passed digits map to a valid bin\n * Note: This method is designed to be called only when the card brand is known && when digits.length is > 1.\n It is not designed to be called directly by the card number component, but, rather, is called only as a\n result of calling `__getIsValidBin` method, also located in this file.\n Putting all the card bin/brand validation logic together it's not possible for this method to be called unless\n digits.length > 1 && there are specific possibleBins.\n *\n * @param {string} digits\n * @param {array} possibleBins\n * @returns {bool}\n */\nconst __checkTwoOrThreeDigits = (digits, possibleBins) => {\n  const possibleBinsLength = possibleBins.length;\n  let isValidBin = false;\n\n  for (let bin = 0; bin < possibleBinsLength; bin++) {\n    if (digits === possibleBins[bin]) {\n      isValidBin = true;\n      break;\n    }\n  }\n  return isValidBin;\n};\n\n/**\n * @description check if provided card number is valid for mastercard\n * currently used only for 2-series mastercards\n *\n * @param {string} cardNum\n * @returns {bool}\n */\nconst __isValidMasterCard = cardNum => {\n  const cardNumsToValidate = cardNum.length < 7 ? cardNum : cardNum.substr(0, 6);\n  const validationNumsLength = cardNumsToValidate.length;\n  const validationRange = binMatrix[MASTERCARD]['ranges'][validationNumsLength]; // eslint-disable-line dot-notation\n  return (\n    validationRange.min <= Number(cardNumsToValidate) &&\n    Number(cardNumsToValidate) <= validationRange.max\n  );\n};\n\n/**\n * @description check if provided card number is valid for discover\n * currently used only for discover cards beginning with 622*\n *\n * @param {string} cardNum\n * @returns {bool}\n */\nconst __isValidDiscoverCard = cardNum => {\n  let digitsToCheck;\n  let isValidBin;\n  let possibleBins;\n  const isFewerThanFourDigits = cardNum.length < 4;\n  if (cardNum.length === 1) {\n    isValidBin = true;\n  } else if (cardNum.substr(0, 2) === '65') {\n    isValidBin = true;\n  } else if (isFewerThanFourDigits) {\n    digitsToCheck = cardNum.substr(0, 3);\n    possibleBins = binMatrix[DISCOVER]['twoOrThreeDigits']; // eslint-disable-line dot-notation\n    isValidBin = __checkTwoOrThreeDigits(digitsToCheck, possibleBins);\n  } else if (cardNum.substr(0, 4) === '6011') {\n    isValidBin = true;\n  } else {\n    const cardNumsToValidate = cardNum.substr(0, 8);\n    const validationNumsLength = cardNumsToValidate.length;\n    const validationRange = binMatrix[DISCOVER]['ranges'][validationNumsLength]; // eslint-disable-line dot-notation\n    isValidBin =\n      validationRange.min <= Number(cardNumsToValidate) &&\n      Number(cardNumsToValidate) <= validationRange.max;\n  }\n  return isValidBin;\n};\n\n/**\n * @description checks bin range of entered card number\n *\n * There is a separate onBlur check for if the entered card number is a complete card number for that brand.\n *\n * The check for whether a card might be elo will return 'elo', 'unknown', or a cardBrand.\n * All cards starting with '4' are valid whether 'elo' or 'visa'.\n * All 'unknown' cards are valid.\n *\n * 'amex' cards currently have only two bin ranges so the for loop is good enough for this brand\n * 'mastercard' 5-series cards have only five bin ranges so the for loop is good enough for this brand\n *\n *\n * @param {string} possibleBrand\n * @param {string} cardNum\n * @returns {bool}\n */\nconst __getIsValidBin = (possibleBrand, cardNum) => {\n  const cardNumLengthOne = cardNum.length === 1;\n  let isValidBin = false;\n  let possibleBins;\n  let firstDigit;\n  let digitsToCheck;\n  switch (possibleBrand) {\n    case ELO:\n    case UNKNOWN:\n    case VISA:\n      isValidBin = true;\n      break;\n    case AMEX:\n      const cardNumLength = cardNum.length;\n      digitsToCheck = cardNum.substr(0, 2);\n      possibleBins = binMatrix[possibleBrand];\n      isValidBin =\n        cardNumLength === 1 ? true : __checkTwoOrThreeDigits(digitsToCheck, possibleBins);\n      break;\n    case MASTERCARD:\n      firstDigit = cardNum[0];\n      digitsToCheck = cardNum.substr(0, 2);\n      const firstDigitIsFive = firstDigit === '5';\n      if (cardNumLengthOne) {\n        isValidBin = true;\n      } else if (firstDigitIsFive) {\n        possibleBins = binMatrix[possibleBrand]['twoDigits']; // eslint-disable-line dot-notation\n        isValidBin = __checkTwoOrThreeDigits(digitsToCheck, possibleBins);\n      } else {\n        isValidBin = __isValidMasterCard(cardNum);\n      }\n      break;\n    case DISCOVER:\n      isValidBin = __isValidDiscoverCard(cardNum);\n      break;\n    default:\n  }\n\n  return isValidBin;\n};\n\n/**\n * @description determines if the entered card number is for a valid cardBrand in a valid bin range\n *\n * @param {string} cardNum\n * @param {array} eloBins\n * @returns {bool}\n */\nexport default (cardNum, eloBins) => {\n  cardNum = getRawValue(cardNum);\n  const possibleBrand = getPossibleBrand(cardNum, eloBins);\n  const isInvalid = possibleBrand === INVALID || !__getIsValidBin(possibleBrand, cardNum);\n\n  return !isInvalid;\n};\n","import { ELECTRON, VISA } from '../constants';\n\n/**\n * @param {array} brands\n * @returns {array}\n */\nexport default brands => {\n  const brandsLen = brands.length;\n  const unfilteredArr = [];\n\n  for (let brand = 0; brand < brandsLen; brand++) {\n    if (brands[brand] === ELECTRON) {\n      unfilteredArr.push(VISA);\n    } else {\n      unfilteredArr.push(brands[brand]);\n    }\n  }\n  // remove possible duplicates and return the result\n  return unfilteredArr.filter((v, i, a) => a.indexOf(v) === i);\n};\n","import { brands } from './brandBinMatrix';\n\nexport default brand => {\n  const brandIsKnown = brands.indexOf(brand) > -1;\n  const prefix = brandIsKnown ? '--' : '';\n  const brandName = brandIsKnown ? brand.toLowerCase() : '';\n  return `${prefix}${brandName}`;\n};\n","import getRawValue from './getRawValue';\n\nconst PRODUCT_ARRAY = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]];\n\n/**\n * @param {string} value\n * @return {bool}\n */\nconst ccMod10Check = value => {\n  if (value) {\n    value = getRawValue(value); // numbers only\n    let l = value.length;\n    let multiple = 0;\n    let sum = 0;\n\n    while (l--) {\n      sum += PRODUCT_ARRAY[multiple][parseInt(value.charAt(l), 10)];\n      multiple ^= 1;\n    }\n\n    return sum > 0 && sum % 10 === 0;\n  }\n\n  return true;\n};\n\n/**\n * @param {string} value\n * @return {bool}\n */\nconst ccMod11Check = value => {\n  if (value) {\n    value = getRawValue(value); // numbers only\n    const len = value.length; // usually 16\n    const digit = value[len - 1]; // tester digit\n    const testDigits = value.substr(0, len - 1); // 15 digits (drops the last value)\n    let i;\n    let myCheck;\n    let total = 0;\n    let temp;\n\n    for (i = len - 1; i > 0; ) {\n      temp = Number(testDigits[--i]);\n      if (i % 2 == 0) {\n        temp *= 2;\n      }\n\n      if (temp > 9) {\n        temp -= 9;\n      }\n\n      total += temp;\n    }\n\n    myCheck = (10 - (total % 10)) % 10;\n    myCheck = (myCheck + 1) % 10;\n\n    if (myCheck == digit) {\n      return true;\n    }\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * @param {string} value\n * @param {bool} checkMod11\n * @return {bool}\n */\nexport default (value, checkMod11) => {\n  const mod10 = true;\n  const mod11 = checkMod11;\n  const isMod10 = ccMod10Check(value);\n  let isMod11 = false;\n\n  if (mod11) {\n    isMod11 = ccMod11Check(value);\n  }\n\n  const passesCheck =\n    mod10 && mod11\n      ? // either\n        isMod10 || isMod11\n      : // specific\n      mod10\n      ? isMod10\n      : isMod11;\n\n  return passesCheck;\n};\n","import acceptedBrandsCheck from './acceptedBrandsCheck';\nimport binCheck from './binCheck';\nimport { brands } from './brandBinMatrix';\nimport getRawValue from './getRawValue';\nimport checkMod from './modCheck';\nimport getPossibleBrand from './possibleBrand';\nimport { AMEX, LENGTH_AMEX, LENGTH_DEFAULT } from '../constants';\n\nexport default (maskedCardNumber, conditions = {}) => {\n  const {\n    cardBins = null,\n    checkMods = false,\n    partnerAcceptedBrands = brands,\n    shouldCheckAcceptedBrands = false,\n    validateMod11 = false\n  } = conditions;\n  const rawValue = getRawValue(maskedCardNumber);\n  const possibleBrand = getPossibleBrand(rawValue, cardBins);\n  const maxLength = possibleBrand === AMEX ? LENGTH_AMEX : LENGTH_DEFAULT;\n  const passesMod = checkMods\n    ? maskedCardNumber.length === maxLength && checkMod(maskedCardNumber, validateMod11)\n    : true;\n  const isSupportedBrand = shouldCheckAcceptedBrands\n    ? acceptedBrandsCheck(possibleBrand, partnerAcceptedBrands)\n    : true;\n  const isValidBin = binCheck(rawValue, cardBins);\n  const isValid = shouldCheckAcceptedBrands ? isSupportedBrand && isValidBin : isValidBin;\n\n  return {\n    brand: possibleBrand,\n    isSupported: isSupportedBrand,\n    isValid,\n    passesMod,\n    value: maskedCardNumber\n  };\n};\n","import { AMEX, AMEX_MASK, NON_AMEX_MASK } from '../constants';\n\nexport default brand => (brand === AMEX ? AMEX_MASK : NON_AMEX_MASK);\n","import { AMEX, ERROR_MAP, INVALID, LENGTH_AMEX, LENGTH_DEFAULT } from '../constants';\nimport checkMod from './modCheck';\n\nexport const validator = (isBlur, conditions = {}) => {\n  const {\n    brand,\n    checkMods = false,\n    checkMod11 = false,\n    isSupported = true,\n    isValid = true,\n    value\n  } = conditions;\n  const maxLength = brand === AMEX ? LENGTH_AMEX : LENGTH_DEFAULT;\n  const isPartialValue = value.length < maxLength;\n  let error;\n\n  /**\n   * `!value` means the field is empty (`ERROR_MAP.empty`)\n   * `!isSupported && brand !== INVALID` means entered value maps to a known card brand\n   but that brand is not supported by the partner or merchant. (`ERROR_MAP.not_supported`)\n   * `brand === INVALID` means the entered value does not map to a known card brand. (`ERROR_MAP.invalid_bin`)\n   * `!isValid` means the value maps to a known card brand but the value's bin is not valid for that card brand.\n   (`ERROR_MAP.invalid_bin_brand`)\n   * `!isPartialValue && checkMods && !checkMod(value, checkMod11)` is for when there is a full and complete\n   value for the card brand but the value does not pass mod checks, when mod checks are enabled. (`ERROR_MAP.invalid_generic`)\n   * `isPartialValue && isBlur` means that the entered value is a partial value for that card brand. (`ERROR_MAP.partial`)\n   */\n  if (!value) {\n    error = ERROR_MAP.empty;\n  } else if (!isSupported && brand !== INVALID) {\n    error = ERROR_MAP.not_supported;\n  } else if (brand === INVALID) {\n    error = ERROR_MAP.invalid_bin;\n  } else if (!isValid) {\n    error = ERROR_MAP.invalid_bin_brand;\n  } else if (!isPartialValue && checkMods && !checkMod(value, checkMod11)) {\n    error = ERROR_MAP.invalid_generic;\n  } else if (isPartialValue && isBlur) {\n    error = ERROR_MAP.partial;\n  }\n\n  return error;\n};\n","import * as constants from './constants';\nimport * as utilities from './utilities';\n\nexport { constants, utilities };\n","/* eslint-disable no-labels */\n\nimport { isArray, NO_MASK_ERROR, NO_PLACEHOLDER_CHAR_IN_MASK } from './index';\n\nconst emptyArray = [];\nconst emptyString = '';\n\n/**\n * This function returns an object with a property conformedValue (string).\n * It will also indicate if any characters were rejected\n *\n * @param {String} rawValue\n * @param {Array} mask\n * @param {Object} config\n * @return {{conformedValue: string, meta: {someCharsRejected: boolean}}}\n */\nexport default function conformToMask(rawValue = emptyString, mask, config = {}) {\n  // These configurations tell us how to conform the mask\n  const {\n    currentCaretPosition = 0,\n    guide = false,\n    placeholder = emptyString,\n    placeholderChars = emptyArray,\n    previousConformedValue = emptyString\n  } = config;\n\n  if (!isArray(mask)) {\n    throw new Error(NO_MASK_ERROR);\n  }\n\n  if (mask.filter(char => placeholderChars.includes(char)).length > 0) {\n    throw new Error(NO_PLACEHOLDER_CHAR_IN_MASK);\n  }\n\n  // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n  const suppressGuide = guide === false && previousConformedValue !== undefined;\n\n  const rawValueLength = rawValue.length;\n  const previousConformedValueLength = previousConformedValue.length;\n  const placeholderLength = placeholder.length;\n  const maskLength = mask.length;\n\n  // This tells us the number of edited characters and the direction in which they were edited (+/-)\n  const editDistance = rawValueLength - previousConformedValueLength;\n\n  // In *no guide* mode, we need to know if the user is trying to add a character or not\n  const isAddition = editDistance > 0;\n\n  // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n  const indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0);\n\n  // Convert rawValue to an array and track whether a character is new\n  const rawValueArr = rawValue.split(emptyString);\n\n  // Remove any placeholder characters from rawValueArr\n  for (let i = rawValueLength - 1; i >= 0; i--) {\n    const char = rawValueArr[i];\n\n    if (!placeholderChars.includes(char)) {\n      const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n\n      if (char === placeholder[shouldOffset ? i - editDistance : i]) {\n        rawValueArr.splice(i, 1);\n      }\n    }\n  }\n\n  // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n  let conformedValue = emptyString;\n  let someCharsRejected = false;\n\n  // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n  placeholderLoop: for (let i = 0; i < placeholderLength; i++) {\n    const charInPlaceholder = placeholder[i];\n\n    // We see one. Let's find out what we can put in it.\n    if (placeholderChars.includes(charInPlaceholder)) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          const rawValueChar = rawValueArr.shift();\n\n          if (rawValueChar === charInPlaceholder && suppressGuide !== true) {\n            conformedValue += charInPlaceholder;\n\n            // And we go to find the next placeholder character that needs filling\n            continue placeholderLoop;\n\n            // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (mask[i].test(rawValueChar)) {\n            conformedValue += rawValueChar;\n\n            // Since we've mapped this placeholder position. We move on to the next one.\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      }\n\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(i, placeholderLength);\n      }\n\n      break;\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  }\n\n  if (suppressGuide && isAddition === false) {\n    let indexOfLastFilledPlaceholderChar = null;\n\n    // Find the last filled placeholder position and substring from there\n    for (let i = 0; i < conformedValue.length; i++) {\n      if (placeholderChars.includes(placeholder[i])) {\n        indexOfLastFilledPlaceholderChar = i;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar === null) {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = emptyString;\n    } else {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    }\n  }\n\n  return { conformedValue, meta: { someCharsRejected } };\n}\n","/* eslint-disable no-lonely-if */\n\nconst emptyArray = [];\nconst emptyString = '';\n\n/**\n * Will return an integer representing the index of where the caret should be moved to next\n *\n * @param {String} conformedValue\n * @param {Number} currentCaretPosition\n * @param {Array} nonRegexChars\n * @param {String} placeholder\n * @param {Array} placeholderChars\n * @param {String} previousConformedValue\n * @param {String} previousPlaceholder\n * @param {String} rawValue\n * @return {Number}\n */\nexport default function adjustCaretPosition({\n  conformedValue = emptyString,\n  currentCaretPosition = 0,\n  nonRegexChars = emptyArray,\n  placeholder = emptyString,\n  placeholderChars = emptyArray,\n  previousConformedValue = emptyString,\n  previousPlaceholder = emptyString,\n  rawValue = emptyString\n}) {\n  if (currentCaretPosition === 0 || !rawValue.length) {\n    return 0;\n  }\n\n  const rawValueLength = rawValue.length;\n  const previousConformedValueLength = previousConformedValue.length;\n  const placeholderLength = placeholder.length;\n  const conformedValueLength = conformedValue.length;\n\n  const editLength = rawValueLength - previousConformedValueLength;\n\n  // If the edit length is positive, that means the user is adding characters, not deleting.\n  const isAddition = editLength > 0;\n\n  // This is the first raw value the user entered that needs to be conformed to mask\n  const isFirstRawValue = previousConformedValueLength === 0;\n\n  // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace. Such cases can also happen when the\n  // user presses the backspace while holding down the ALT key.\n  const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue;\n\n  if (isPartialMultiCharEdit) {\n    return currentCaretPosition;\n  }\n\n  // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\n  // same as the original `previousConformedValue`. We handle this case differently for caret\n  // positioning.\n  const possiblyHasRejectedChar =\n    isAddition && (previousConformedValue === conformedValue || conformedValue === placeholder);\n\n  let startingSearchIndex = 0;\n  let trackRightCharacter;\n  let targetChar;\n\n  if (possiblyHasRejectedChar) {\n    startingSearchIndex = currentCaretPosition - editLength;\n  } else {\n    const normalizedConformedValue = conformedValue.toLowerCase();\n    const normalizedRawValue = rawValue.toLowerCase();\n\n    // Then we take all characters that come before where the caret currently is.\n    const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString);\n\n    // Now we find all the characters in the left half that exist in the conformed input\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\n    const intersection = leftHalfChars.filter(\n      char => normalizedConformedValue.indexOf(char) !== -1\n    );\n\n    // The last character in the intersection is the character we want to look for in the conformed\n    // value and the one we want to adjust the caret close to\n    targetChar = intersection[intersection.length - 1];\n\n    // Calculate the number of mask characters in the previous placeholder\n    // from the start of the string up to the place where the caret is\n    const previousLeftMaskChars = previousPlaceholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter(char => !placeholderChars.includes(char)).length;\n\n    // Calculate the number of mask characters in the current placeholder\n    // from the start of the string up to the place where the caret is\n    const leftMaskChars = placeholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter(char => !placeholderChars.includes(char)).length;\n\n    // Has the number of mask characters up to the caret changed?\n    const maskLengthChanged = leftMaskChars !== previousLeftMaskChars;\n\n    // Detect if `targetChar` is a mask character and has moved to the left\n    const targetIsMaskMovingLeft =\n      previousPlaceholder[intersection.length - 1] !== undefined &&\n      placeholder[intersection.length - 2] !== undefined &&\n      !placeholderChars.includes(previousPlaceholder[intersection.length - 1]) &&\n      previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] &&\n      previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2];\n\n    // If deleting and the `targetChar` `is a mask character and `maskLengthChanged` is true\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\n    // if we are not at the end of the string.\n    // In this case, change tracking strategy and track the character to the right of the caret.\n    if (\n      !isAddition &&\n      (maskLengthChanged || targetIsMaskMovingLeft) &&\n      previousLeftMaskChars > 0 &&\n      placeholder.indexOf(targetChar) > -1 &&\n      rawValue[currentCaretPosition] !== undefined\n    ) {\n      trackRightCharacter = true;\n      targetChar = rawValue[currentCaretPosition];\n    }\n\n    // We need to know how many times it occurs in the intersection\n    const countTargetCharInIntersection = intersection.filter(char => char === targetChar).length;\n\n    // We need to know if the placeholder contains characters that look like\n    // our `targetChar`, so we don't select one of those by mistake.\n    const countTargetCharInPlaceholder = placeholder\n      .split(emptyString)\n      .filter(\n        (char, index) =>\n          !nonRegexChars.includes(char) && char === targetChar && rawValue[index] !== char\n      ).length;\n\n    // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking for is:\n    const requiredNumberOfMatches =\n      countTargetCharInPlaceholder +\n      countTargetCharInIntersection +\n      // The character to the right of the caret isn't included in `intersection`\n      // so add one if we are tracking the character to the right\n      (trackRightCharacter ? 1 : 0);\n\n    // Now we start looking for the location of the `targetChar`.\n    // We keep looping forward and store the index in every iteration. Once we have encountered\n    // enough occurrences of the target character, we break out of the loop\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\n    let numberOfEncounteredMatches = 0;\n    for (let i = 0; i < conformedValueLength; i++) {\n      const conformedValueChar = normalizedConformedValue[i];\n\n      startingSearchIndex = i + 1;\n\n      if (conformedValueChar === targetChar) {\n        numberOfEncounteredMatches++;\n      }\n\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n        break;\n      }\n    }\n  }\n\n  // In case of addition, we fast forward.\n  if (isAddition) {\n    // We want to remember the last placeholder character encountered so that if the mask\n    // contains more characters after the last placeholder character, we don't forward the caret\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\n    let lastPlaceholderChar = startingSearchIndex;\n\n    for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n      if (placeholderChars.includes(placeholder[i])) {\n        lastPlaceholderChar = i;\n      }\n\n      if (placeholderChars.includes(placeholder[i]) || i === placeholderLength) {\n        return lastPlaceholderChar;\n      }\n    }\n  } else {\n    // In case of deletion, we rewind.\n    if (trackRightCharacter) {\n      // Searching for the character that was to the right of the caret\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\n      for (let i = startingSearchIndex - 1; i >= 0; i--) {\n        if (conformedValue[i] === targetChar || i === 0) {\n          return i;\n        }\n      }\n    } else {\n      // Searching for the first placeholder or caret trap to the left\n      for (let i = startingSearchIndex; i >= 0; i--) {\n        if (placeholderChars.includes(placeholder[i - 1]) || i === 0) {\n          return i;\n        }\n      }\n    }\n  }\n\n  return -1;\n}\n","import {\n  adjustCaretPosition,\n  conformToMask,\n  cleanMask,\n  safeSetSelection,\n  isHTMLInputElement,\n  isNil,\n  NO_INPUT_ERROR\n} from './index';\n\n/**\n * This function takes a configuration and returns an object with an update method.\n * The update method is used to conform the raw value to the mask you provide in the config\n *\n * @param {Object} config\n * @return {{state: Object, update: Function}}\n */\nexport default function createTextMaskInputElement(config = {}) {\n  const state = {\n    previousConformedValue: undefined,\n    previousPlaceholder: undefined\n  };\n\n  return {\n    state,\n\n    update(\n      rawValue,\n      { guide = false, inputElement, mask, placeholderChar = 'X', upperCaseValue = false } = config\n    ) {\n      if (!isHTMLInputElement(inputElement)) {\n        throw new Error(NO_INPUT_ERROR);\n      }\n\n      const { selectionEnd: currentCaretPosition, value: inputValue } = inputElement;\n\n      if (isNil(rawValue)) {\n        rawValue = inputValue;\n      } else {\n        rawValue = rawValue.toString();\n      }\n\n      const { mask: cleanedMask, placeholder, nonRegexChars, placeholderChars } = cleanMask(\n        mask,\n        placeholderChar\n      );\n\n      if (rawValue === state.previousConformedValue && placeholder === state.previousPlaceholder) {\n        return {\n          ...state,\n          adjustedCaretPosition: currentCaretPosition,\n          conformedValue: rawValue\n        };\n      }\n\n      const { conformedValue } = conformToMask(rawValue, cleanedMask, {\n        currentCaretPosition,\n        guide,\n        placeholder,\n        placeholderChars,\n        previousConformedValue: state.previousConformedValue\n      });\n\n      const adjustedCaretPosition = adjustCaretPosition({\n        conformedValue,\n        currentCaretPosition,\n        nonRegexChars,\n        placeholder,\n        placeholderChars,\n        previousConformedValue: state.previousConformedValue,\n        previousPlaceholder: state.previousPlaceholder,\n        rawValue\n      });\n\n      // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n      const inputValueShouldBeEmpty = conformedValue === placeholder && adjustedCaretPosition === 0;\n      const inputElementValue = inputValueShouldBeEmpty\n        ? ''\n        : upperCaseValue\n        ? conformedValue.toUpperCase()\n        : conformedValue;\n\n      state.previousConformedValue = inputElementValue;\n      state.previousPlaceholder = placeholder;\n\n      inputElement.value = inputElementValue;\n      safeSetSelection(inputElement, adjustedCaretPosition);\n\n      return {\n        ...state,\n        adjustedCaretPosition,\n        conformedValue: inputElementValue\n      };\n    }\n  };\n}\n","import { NO_MASK_ERROR } from './index';\n\nconst isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\nconst defer = typeof requestAnimationFrame === 'undefined' ? setTimeout : requestAnimationFrame;\n\n/**\n * Set cursor position on an input element\n * @param {HTMLElement} element\n * @param {Number} selectionPosition\n */\nexport function safeSetSelection(element, selectionPosition) {\n  if (document.activeElement === element) {\n    if (isAndroid) {\n      defer(() => element.setSelectionRange(selectionPosition, selectionPosition, 'none'), 0);\n    } else {\n      element.setSelectionRange(selectionPosition, selectionPosition, 'none');\n    }\n  }\n}\n\n/**\n * Tells you whether a value is a string\n * @param {String} value\n * @return {Boolean}\n */\nexport function isString(value) {\n  return typeof value === 'string' || value instanceof String;\n}\n\n/**\n * Tells you whether a value is a array\n * @param {String} value\n * @return {Boolean}\n */\nexport function isArray(value) {\n  return (Array.isArray && Array.isArray(value)) || value instanceof Array;\n}\n\n/**\n * Tells you whether a value is nil\n * @param {String} value\n * @return {Boolean}\n */\nexport function isNil(value) {\n  return typeof value === 'undefined' || value === null;\n}\n\n/**\n * Tells you whether an element is an input type\n * @param {HTMLElement} element\n * @return {Boolean}\n */\nexport function isHTMLInputElement(element) {\n  return (\n    (element instanceof Element || element instanceof HTMLDocument) &&\n    element.nodeType === 1 &&\n    element.tagName.toLowerCase() === 'input'\n  );\n}\n\n/**\n * Tells you whether a value is a string and has a length > 0\n * @param {String} value\n * @return {Boolean}\n */\nexport function validString(value) {\n  return isString(value) && value.length > 0;\n}\n\n/**\n * Returns the display name of a component\n * @param {Component} WrappedComponent\n * @return {string | * | string}\n */\nexport function getComponentDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\n/**\n * Returns an object containing all the info needed for Text-Mask library\n * @param {Array} mask\n * @param {String} placeholderChar\n * @return {{mask: [], nonRegexChars: [], placeholder: string, placeholderChars: []}}\n */\nexport function cleanMask(mask, placeholderChar = 'X') {\n  if (!isArray(mask)) {\n    throw new Error(NO_MASK_ERROR);\n  }\n\n  const cleanedMask = mask.reduce(\n    (maskObj, char) => {\n      const { mask, placeholderChars, placeholder } = maskObj;\n      const maskChar = char && char.mask instanceof RegExp ? char.mask : char;\n      const placeChar =\n        char && typeof char.placeholder === 'string' ? char.placeholder.charAt(0) : placeholderChar;\n\n      mask.push(typeof maskChar === 'string' ? maskChar.charAt(0) : maskChar);\n\n      placeholder.push(\n        char instanceof RegExp || char.mask instanceof RegExp\n          ? placeChar\n          : char.toString().charAt(0)\n      );\n\n      if (!placeholderChars.includes(placeChar)) {\n        placeholderChars.push(placeChar);\n      }\n\n      return maskObj;\n    },\n    {\n      mask: [],\n      placeholder: [],\n      placeholderChars: []\n    }\n  );\n\n  // Filter out empty string\n  const cleanMask = cleanedMask.mask.filter(Boolean);\n  // Create placeholder string representation\n  const placeholderStr = cleanedMask.placeholder.join('');\n  // Remove any duplicates from placeholder array and filter out empty string\n  const nonRegexChars = [...new Set(cleanedMask.placeholder.filter(Boolean))];\n  // Only use placeholder chars present in nonRegexChars array\n  let placeholderChars = cleanedMask.placeholderChars.filter(char => nonRegexChars.includes(char));\n  // If our `placeholderChars` array is empty, default to using `placeholderChar`\n  if (placeholderChars.length === 0) {\n    placeholderChars = [placeholderChar];\n  }\n\n  return {\n    mask: cleanMask,\n    nonRegexChars,\n    placeholder: placeholderStr,\n    placeholderChars\n  };\n}\n","export const NO_MASK_ERROR = `An array containing a valid mask is required. Please refer to LINK_WIKI for more information`;\nexport const NO_INPUT_ERROR = `An input element is required to enable Masking. Please refer to LINK_WIKI for more information`;\nexport const NO_PLACEHOLDER_CHAR_IN_MASK =\n  'A placeholder character must not be used as part of the mask. ' +\n  'Please specify a character that is not present in your mask as your placeholder character.';\n","export { default as conformToMask } from './conformToMask';\nexport { default as adjustCaretPosition } from './adjustCaretPosition';\nexport { default as createTextMaskInputElement } from './createTextMaskInputElement';\n\nexport {\n  cleanMask,\n  safeSetSelection,\n  isString,\n  isArray,\n  isNil,\n  isHTMLInputElement,\n  validString,\n  getComponentDisplayName\n} from './utilities';\n\nexport { NO_INPUT_ERROR, NO_MASK_ERROR, NO_PLACEHOLDER_CHAR_IN_MASK } from './constants';\n","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","import { useRef, useState, useEffect } from 'react';\nimport {\n  NO_INPUT_ERROR,\n  NO_MASK_ERROR,\n  createTextMaskInputElement,\n  isArray,\n  isNil\n} from '../index';\n\n/**\n * Custom hook to give an input element Text-Masking capabilities\n * This component will default w/ the empty string as the `value setting\n * @param {Object} props\n * @return {Object} shape is as follows...\n * {\n *    getInputProps: {\n *      onChange: Function,\n *      ref: Object,\n *      value: String -- Defaults to empty string. This may set any `controlled` boolean flags to TRUE (e.g. props.value !== undefined)\n *    },\n *    meta: {\n *      adjustedCaretPosition: (undefined|Number),\n *      placeholder: String\n *    }\n * }\n */\nexport default function useTextMask(props = {}) {\n  const {\n    guide = false,\n    mask,\n    onChange,\n    placeholderChar = 'X',\n    upperCaseValue = false,\n    value\n  } = props;\n\n  const inputRef = useRef(null);\n  const textMask = useRef(null);\n  const [state, setState] = useState({\n    adjustedCaretPosition: undefined,\n    conformedValue: isNil(value) ? '' : value.toString(),\n    placeholder: undefined\n  });\n\n  const createTextMask = () =>\n    createTextMaskInputElement({\n      guide,\n      inputElement: inputRef.current,\n      mask,\n      placeholderChar,\n      upperCaseValue\n    });\n\n  useEffect(() => {\n    textMask.current = createTextMask();\n    const {\n      adjustedCaretPosition,\n      conformedValue,\n      previousPlaceholder: placeholder\n    } = textMask.current.update();\n    setState({ adjustedCaretPosition, conformedValue, placeholder });\n  }, [guide, mask, placeholderChar]);\n\n  useEffect(() => {\n    if (textMask.current) {\n      const {\n        adjustedCaretPosition,\n        conformedValue,\n        previousPlaceholder: placeholder\n      } = textMask.current.update(value);\n      setState({ adjustedCaretPosition, conformedValue, placeholder });\n    }\n  }, [value]);\n\n  useEffect(() => {\n    if (inputRef.current) {\n      if (isArray(mask) && mask.length > 0) {\n        textMask.current = createTextMask();\n        const {\n          adjustedCaretPosition,\n          conformedValue,\n          previousPlaceholder: placeholder\n        } = textMask.current.update(value);\n        setState({ adjustedCaretPosition, conformedValue, placeholder });\n      } else {\n        throw new Error(NO_MASK_ERROR);\n      }\n    } else {\n      throw new Error(NO_INPUT_ERROR);\n    }\n  }, []);\n\n  /**\n   * @param {Event} e\n   * @protected\n   */\n  function handleChange(e) {\n    const {\n      adjustedCaretPosition,\n      conformedValue,\n      previousPlaceholder: placeholder\n    } = textMask.current.update();\n\n    const newState = {\n      adjustedCaretPosition,\n      conformedValue,\n      placeholder\n    };\n\n    setState(newState);\n\n    typeof onChange === 'function' && onChange(e, newState);\n  }\n\n  return {\n    getInputProps: {\n      onChange: handleChange,\n      ref: inputRef,\n      value: state.conformedValue\n    },\n    meta: {\n      adjustedCaretPosition: state.adjustedCaretPosition,\n      placeholder: state.placeholder\n    }\n  };\n}\n\n/**\n * Render Prop implemention using our custom hook\n * @constructor\n */\nexport function TextMaskInput({ children, ...props }) {\n  return children(useTextMask(props));\n}\n","export { default as useTextMask, TextMaskInput } from './useTextMask';\n"],"sourceRoot":""}