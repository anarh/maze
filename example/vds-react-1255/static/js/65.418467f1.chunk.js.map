{"version":3,"sources":["../../../../../src/js/card-number/constants/index.js","../../../../../src/js/card-number/utilities/brandBinMatrix.js","../../../../../src/js/card-number/utilities/acceptedBrandsCheck.js","../../../../../src/js/card-number/utilities/getRawValue.js","../../../../../src/js/card-number/utilities/possibleBrand.js","../../../../../src/js/card-number/utilities/binCheck.js","../../../../../src/js/card-number/utilities/filterAcceptedBrands.js","../../../../../src/js/card-number/utilities/getBrandClassName.js","../../../../../src/js/card-number/utilities/modCheck.js","../../../../../src/js/card-number/utilities/getCardInfo.js","../../../../../src/js/card-number/utilities/getMask.js","../../../../../src/js/card-number/utilities/validator.js","../../../../src/js/text-mask/conformToMask.js","../../../../src/js/text-mask/adjustCaretPosition.js","../../../../src/js/text-mask/createTextMaskInputElement.js","../../../../src/js/text-mask/utilities.js","../../../../src/js/text-mask/constants.js","../node_modules/@babel/runtime/helpers/toConsumableArray.js","../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/iterableToArray.js","../node_modules/@babel/runtime/helpers/nonIterableSpread.js","../../../../../src/js/text-mask/react/useTextMask.js"],"names":["COMPONENT_CLASSNAME","COMPONENT_WRAPPER_CLASSNAME","INDICATOR_CLASSNAME","INDICATOR_WRAPPER_CLASSNAME","LENGTH_AMEX","LENGTH_DEFAULT","FIVE_DIGITS","FOUR_DIGITS","SIX_DIGITS","AMEX_MASK","NON_AMEX_MASK","AMEX","DISCOVER","ELECTRON","ELO","INVALID","MASTERCARD","UNKNOWN","VISA","EMPTY","INVALID_BIN","INVALID_BIN_BRAND","INVALID_GENERIC","NOT_SUPPORTED","PARTIAL","ERROR_MAP","empty","invalid_bin","invalid_bin_brand","invalid_generic","not_supported","partial","brands","brandMatrix","binMatrix","fourDigits","ranges","4","max","min","5","6","7","8","twoOrThreeDigits","1","2","3","twoDigits","acceptedBrands","acceptedBrandsLength","isAccepted","cardBrand","brand","value","cardNum","eloBins","possibleBrand","firstDigit","i","eloOrOther","__checkTwoOrThreeDigits","digits","possibleBins","possibleBinsLength","isValidBin","bin","__getIsValidBin","cardNumLengthOne","cardNumLength","digitsToCheck","cardNumsToValidate","validationNumsLength","validationRange","Number","__isValidMasterCard","isFewerThanFourDigits","__isValidDiscoverCard","getRawValue","getPossibleBrand","brandsLen","unfilteredArr","a","brandIsKnown","prefix","brandName","PRODUCT_ARRAY","mod11","isMod10","l","multiple","sum","parseInt","ccMod10Check","isMod11","len","digit","testDigits","total","temp","myCheck","ccMod11Check","mod10","conditions","cardBins","checkMods","partnerAcceptedBrands","shouldCheckAcceptedBrands","validateMod11","rawValue","maxLength","passesMod","maskedCardNumber","checkMod","isSupportedBrand","acceptedBrandsCheck","binCheck","isValid","isSupported","validator","isBlur","checkMod11","isPartialValue","error","emptyArray","conformToMask","mask","config","currentCaretPosition","guide","placeholder","placeholderChars","previousConformedValue","isArray","Error","char","suppressGuide","rawValueLength","previousConformedValueLength","placeholderLength","maskLength","editDistance","isAddition","indexOfFirstChange","rawValueArr","shouldOffset","conformedValue","someCharsRejected","placeholderLoop","charInPlaceholder","rawValueChar","indexOfLastFilledPlaceholderChar","meta","adjustCaretPosition","nonRegexChars","previousPlaceholder","conformedValueLength","editLength","startingSearchIndex","normalizedConformedValue","intersection","normalizedRawValue","targetChar","previousLeftMaskChars","maskLengthChanged","targetIsMaskMovingLeft","trackRightCharacter","countTargetCharInIntersection","requiredNumberOfMatches","numberOfEncounteredMatches","lastPlaceholderChar","createTextMaskInputElement","state","undefined","update","inputElement","placeholderChar","upperCaseValue","isHTMLInputElement","inputValue","isNil","cleanMask","cleanedMask","adjustedCaretPosition","inputValueShouldBeEmpty","inputElementValue","safeSetSelection","isAndroid","navigator","test","defer","requestAnimationFrame","setTimeout","element","selectionPosition","document","Array","maskObj","maskChar","placeChar","placeholderStr","Set","NO_MASK_ERROR","NO_INPUT_ERROR","NO_PLACEHOLDER_CHAR_IN_MASK","arrayWithoutHoles","iterableToArray","nonIterableSpread","module","exports","arr","arr2","length","iter","Symbol","iterator","Object","prototype","toString","call","from","TypeError","useTextMask","props","onChange","inputRef","useRef","textMask","useState","setState","createTextMask","newState","e","useEffect","getInputProps","ref"],"mappings":"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","file":"static/js/65.418467f1.chunk.js","sourcesContent":["// Component rendering-related items\nexport const COMPONENT_CLASSNAME = 'vds-input-card';\nexport const COMPONENT_WRAPPER_CLASSNAME = 'vds-cardnumber';\nexport const INDICATOR_CLASSNAME = 'vds-card-indicator';\nexport const INDICATOR_WRAPPER_CLASSNAME = 'vds-input-option';\nexport const LENGTH_AMEX = 17; // 15-digit card number plus 2 masked spaces\nexport const LENGTH_DEFAULT = 19; // 16-digit card number plus 3 masked spaces\nexport const FIVE_DIGITS = [/\\d/, /\\d/, /\\d/, /\\d/, /\\d/];\nexport const FOUR_DIGITS = [/\\d/, /\\d/, /\\d/, /\\d/];\nexport const SIX_DIGITS = [/\\d/, /\\d/, /\\d/, /\\d/, /\\d/, /\\d/];\nexport const AMEX_MASK = [...FOUR_DIGITS, ' ', ...SIX_DIGITS, ' ', ...FIVE_DIGITS];\nexport const NON_AMEX_MASK = [\n  ...FOUR_DIGITS,\n  ' ',\n  ...FOUR_DIGITS,\n  ' ',\n  ...FOUR_DIGITS,\n  ' ',\n  ...FOUR_DIGITS\n];\n\n/**\n * Card Brands\n *\n * All brands are used for when there is at least one digit entered by the user\n *\n */\nexport const AMEX = 'AMEX';\nexport const DISCOVER = 'DISCOVER';\nexport const ELECTRON = 'ELECTRON';\nexport const ELO = 'ELO';\nexport const INVALID = 'INVALID';\nexport const MASTERCARD = 'MASTERCARD';\nexport const UNKNOWN = 'UNKNOWN';\nexport const VISA = 'VISA';\n\n// Card Validation Errors\nexport const EMPTY = 'EMPTY';\nexport const INVALID_BIN = 'INVALID_BIN';\nexport const INVALID_BIN_BRAND = 'INVALID_BIN_BRAND';\nexport const INVALID_GENERIC = 'INVALID_GENERIC';\nexport const NOT_SUPPORTED = 'NOT_SUPPORTED';\nexport const PARTIAL = 'PARTIAL';\n\n// These errors are all triggered onChange except where noted\nexport const ERROR_MAP = {\n  empty: EMPTY, // field is empty\n  invalid_bin: INVALID_BIN, // first digit does not map to a known card brand\n  invalid_bin_brand: INVALID_BIN_BRAND, // brand is recognized but bin range is not valid\n  invalid_generic: INVALID_GENERIC, // card number is invalid for some other reason not specified\n  not_supported: NOT_SUPPORTED, // brand is recognized but not supported by merchant / partner\n  partial: PARTIAL // partial value, triggered only onBlur\n};\n","import { AMEX, DISCOVER, ELO, MASTERCARD, VISA } from '../constants';\n\nexport const brands = [AMEX, DISCOVER, ELO, MASTERCARD, VISA];\n\n/**\n  * If the value's first digit does not map to one of these it will cause the\n  `possibleBrand` to be `INVALID` and the validator to return `invalid_bin`.\n  */\nexport const brandMatrix = {\n  '2': MASTERCARD,\n  '3': AMEX,\n  '4': VISA,\n  '5': MASTERCARD,\n  '6': DISCOVER\n};\n\n/**\n  * If the value's first digit maps to one of the `brandMatrix` brands but the rest of the\n  value, aka 'bin,' does not follow the below logic, it will cause the `possibleBrand` to be\n  one of the known brands in `brandMatrix` and the validator to return `invalid_bin_brand`.\n  */\nexport const binMatrix = {\n  AMEX: ['34', '37'],\n  DISCOVER: {\n    fourDigits: ['6011'],\n    ranges: {\n      4: {\n        max: 6229,\n        min: 6221\n      },\n      5: {\n        max: 62292,\n        min: 62212\n      },\n      6: {\n        max: 622925,\n        min: 622126\n      },\n      7: {\n        max: 6229259,\n        min: 6221260\n      },\n      8: {\n        max: 62292599,\n        min: 62212600\n      }\n    },\n    twoOrThreeDigits: ['60', '62', '65', '601', '622']\n  },\n  MASTERCARD: {\n    ranges: {\n      1: {\n        max: 2,\n        min: 2\n      },\n      2: {\n        max: 27,\n        min: 22\n      },\n      3: {\n        max: 272,\n        min: 222\n      },\n      4: {\n        max: 2720,\n        min: 2221\n      },\n      5: {\n        max: 27209,\n        min: 22210\n      },\n      6: {\n        max: 272099,\n        min: 222100\n      }\n    },\n    twoDigits: ['51', '52', '53', '54', '55']\n  },\n  VISA: ['4']\n};\n","import { brands } from './brandBinMatrix';\nimport { UNKNOWN } from '../constants';\n\n/**\n * @description check user-entered cardBrand against merchant- and partner-supported brands.\n * Call function only if shouldValidateAcceptedCards prop is true in your component.\n *\n * @param {string} cardBrand\n * @param {array} acceptedBrands defaults to all brands\n * @return {bool}\n */\nexport default (cardBrand, acceptedBrands = brands) => {\n  const acceptedBrandsLength = acceptedBrands.length;\n  let isAccepted = false;\n  if (cardBrand === UNKNOWN) {\n    return true;\n  }\n\n  for (let brand = 0; brand < acceptedBrandsLength; brand++) {\n    if (acceptedBrands[brand] === cardBrand) {\n      isAccepted = true;\n      break;\n    }\n  }\n\n  return isAccepted;\n};\n","export default value => value.toString().replace(/\\s+/g, '');\n","/* eslint-disable spellcheck/spell-checker */\nimport { brandMatrix } from './brandBinMatrix';\nimport { ELO, INVALID, UNKNOWN } from '../constants';\n\n/**\n * @description Checks if the entered card number is for an Elo bin\n *\n * @param {string} cardNum\n * @param {string} cardBrand\n * @param {array} eloBins\n * @returns {string}\n */\nexport const eloOrOther = (cardNum, cardBrand, eloBins) => {\n  if (eloBins && eloBins.length > 0) {\n    for (let i = 0; i < eloBins.length; i++) {\n      if (cardNum.indexOf(eloBins[i].toString()) === 0) {\n        // cardNum starts with an Elo prefix and is definitely Elo\n        return ELO;\n      } else if (eloBins[i].toString().indexOf(cardNum) === 0) {\n        // cardNum is part of an Elo prefix but not confirmed Elo\n        return UNKNOWN;\n      }\n    }\n  }\n  return cardBrand;\n};\n\n/**\n * @description Checks what is the cardBrand based on provided value\n *\n * @param {string} cardNum\n * @param {array} eloBins\n * @returns {string}\n */\nconst getPossibleBrand = (cardNum, eloBins) => {\n  let possibleBrand = UNKNOWN;\n  if (!cardNum.length) {\n    return possibleBrand;\n  }\n  const firstDigit = cardNum[0];\n  possibleBrand = brandMatrix[firstDigit] || INVALID;\n  possibleBrand = possibleBrand === INVALID ? INVALID : eloOrOther(cardNum, possibleBrand, eloBins);\n\n  return possibleBrand;\n};\n\nexport default getPossibleBrand;\n","/* eslint-disable spellcheck/spell-checker */\nimport { binMatrix } from './brandBinMatrix';\nimport getRawValue from './getRawValue';\nimport getPossibleBrand from './possibleBrand.js';\nimport { AMEX, DISCOVER, ELO, INVALID, MASTERCARD, UNKNOWN, VISA } from '../constants';\n\n/**\n * @description execute for loop for common use cases to determine if passed digits map to a valid bin\n * Note: This method is designed to be called only when the card brand is known && when digits.length is > 1.\n It is not designed to be called directly by the card number component, but, rather, is called only as a\n result of calling `__getIsValidBin` method, also located in this file.\n Putting all the card bin/brand validation logic together it's not possible for this method to be called unless\n digits.length > 1 && there are specific possibleBins.\n *\n * @param {string} digits\n * @param {array} possibleBins\n * @returns {bool}\n */\nconst __checkTwoOrThreeDigits = (digits, possibleBins) => {\n  const possibleBinsLength = possibleBins.length;\n  let isValidBin = false;\n\n  for (let bin = 0; bin < possibleBinsLength; bin++) {\n    if (digits === possibleBins[bin]) {\n      isValidBin = true;\n      break;\n    }\n  }\n  return isValidBin;\n};\n\n/**\n * @description check if provided card number is valid for mastercard\n * currently used only for 2-series mastercards\n *\n * @param {string} cardNum\n * @returns {bool}\n */\nconst __isValidMasterCard = cardNum => {\n  const cardNumsToValidate = cardNum.length < 7 ? cardNum : cardNum.substr(0, 6);\n  const validationNumsLength = cardNumsToValidate.length;\n  const validationRange = binMatrix[MASTERCARD]['ranges'][validationNumsLength]; // eslint-disable-line dot-notation\n  return (\n    validationRange.min <= Number(cardNumsToValidate) &&\n    Number(cardNumsToValidate) <= validationRange.max\n  );\n};\n\n/**\n * @description check if provided card number is valid for discover\n * currently used only for discover cards beginning with 622*\n *\n * @param {string} cardNum\n * @returns {bool}\n */\nconst __isValidDiscoverCard = cardNum => {\n  let digitsToCheck;\n  let isValidBin;\n  let possibleBins;\n  const isFewerThanFourDigits = cardNum.length < 4;\n  if (cardNum.length === 1) {\n    isValidBin = true;\n  } else if (cardNum.substr(0, 2) === '65') {\n    isValidBin = true;\n  } else if (isFewerThanFourDigits) {\n    digitsToCheck = cardNum.substr(0, 3);\n    possibleBins = binMatrix[DISCOVER]['twoOrThreeDigits']; // eslint-disable-line dot-notation\n    isValidBin = __checkTwoOrThreeDigits(digitsToCheck, possibleBins);\n  } else if (cardNum.substr(0, 4) === '6011') {\n    isValidBin = true;\n  } else {\n    const cardNumsToValidate = cardNum.substr(0, 8);\n    const validationNumsLength = cardNumsToValidate.length;\n    const validationRange = binMatrix[DISCOVER]['ranges'][validationNumsLength]; // eslint-disable-line dot-notation\n    isValidBin =\n      validationRange.min <= Number(cardNumsToValidate) &&\n      Number(cardNumsToValidate) <= validationRange.max;\n  }\n  return isValidBin;\n};\n\n/**\n * @description checks bin range of entered card number\n *\n * There is a separate onBlur check for if the entered card number is a complete card number for that brand.\n *\n * The check for whether a card might be elo will return 'elo', 'unknown', or a cardBrand.\n * All cards starting with '4' are valid whether 'elo' or 'visa'.\n * All 'unknown' cards are valid.\n *\n * 'amex' cards currently have only two bin ranges so the for loop is good enough for this brand\n * 'mastercard' 5-series cards have only five bin ranges so the for loop is good enough for this brand\n *\n *\n * @param {string} possibleBrand\n * @param {string} cardNum\n * @returns {bool}\n */\nconst __getIsValidBin = (possibleBrand, cardNum) => {\n  const cardNumLengthOne = cardNum.length === 1;\n  let isValidBin = false;\n  let possibleBins;\n  let firstDigit;\n  let digitsToCheck;\n  switch (possibleBrand) {\n    case ELO:\n    case UNKNOWN:\n    case VISA:\n      isValidBin = true;\n      break;\n    case AMEX:\n      const cardNumLength = cardNum.length;\n      digitsToCheck = cardNum.substr(0, 2);\n      possibleBins = binMatrix[possibleBrand];\n      isValidBin =\n        cardNumLength === 1 ? true : __checkTwoOrThreeDigits(digitsToCheck, possibleBins);\n      break;\n    case MASTERCARD:\n      firstDigit = cardNum[0];\n      digitsToCheck = cardNum.substr(0, 2);\n      const firstDigitIsFive = firstDigit === '5';\n      if (cardNumLengthOne) {\n        isValidBin = true;\n      } else if (firstDigitIsFive) {\n        possibleBins = binMatrix[possibleBrand]['twoDigits']; // eslint-disable-line dot-notation\n        isValidBin = __checkTwoOrThreeDigits(digitsToCheck, possibleBins);\n      } else {\n        isValidBin = __isValidMasterCard(cardNum);\n      }\n      break;\n    case DISCOVER:\n      isValidBin = __isValidDiscoverCard(cardNum);\n      break;\n    default:\n  }\n\n  return isValidBin;\n};\n\n/**\n * @description determines if the entered card number is for a valid cardBrand in a valid bin range\n *\n * @param {string} cardNum\n * @param {array} eloBins\n * @returns {bool}\n */\nexport default (cardNum, eloBins) => {\n  cardNum = getRawValue(cardNum);\n  const possibleBrand = getPossibleBrand(cardNum, eloBins);\n  const isInvalid = possibleBrand === INVALID || !__getIsValidBin(possibleBrand, cardNum);\n\n  return !isInvalid;\n};\n","import { ELECTRON, VISA } from '../constants';\n\n/**\n * @param {array} brands\n * @returns {array}\n */\nexport default brands => {\n  const brandsLen = brands.length;\n  const unfilteredArr = [];\n\n  for (let brand = 0; brand < brandsLen; brand++) {\n    if (brands[brand] === ELECTRON) {\n      unfilteredArr.push(VISA);\n    } else {\n      unfilteredArr.push(brands[brand]);\n    }\n  }\n  // remove possible duplicates and return the result\n  return unfilteredArr.filter((v, i, a) => a.indexOf(v) === i);\n};\n","import { brands } from './brandBinMatrix';\n\nexport default brand => {\n  const brandIsKnown = brands.indexOf(brand) > -1;\n  const prefix = brandIsKnown ? '--' : '';\n  const brandName = brandIsKnown ? brand.toLowerCase() : '';\n  return `${prefix}${brandName}`;\n};\n","import getRawValue from './getRawValue';\n\nconst PRODUCT_ARRAY = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]];\n\n/**\n * @param {string} value\n * @return {bool}\n */\nconst ccMod10Check = value => {\n  if (value) {\n    value = getRawValue(value); // numbers only\n    let l = value.length;\n    let multiple = 0;\n    let sum = 0;\n\n    while (l--) {\n      sum += PRODUCT_ARRAY[multiple][parseInt(value.charAt(l), 10)];\n      multiple ^= 1;\n    }\n\n    return sum > 0 && sum % 10 === 0;\n  }\n\n  return true;\n};\n\n/**\n * @param {string} value\n * @return {bool}\n */\nconst ccMod11Check = value => {\n  if (value) {\n    value = getRawValue(value); // numbers only\n    const len = value.length; // usually 16\n    const digit = value[len - 1]; // tester digit\n    const testDigits = value.substr(0, len - 1); // 15 digits (drops the last value)\n    let i;\n    let myCheck;\n    let total = 0;\n    let temp;\n\n    for (i = len - 1; i > 0; ) {\n      temp = Number(testDigits[--i]);\n      if (i % 2 == 0) {\n        temp *= 2;\n      }\n\n      if (temp > 9) {\n        temp -= 9;\n      }\n\n      total += temp;\n    }\n\n    myCheck = (10 - (total % 10)) % 10;\n    myCheck = (myCheck + 1) % 10;\n\n    if (myCheck == digit) {\n      return true;\n    }\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * @param {string} value\n * @param {bool} checkMod11\n * @return {bool}\n */\nexport default (value, checkMod11) => {\n  const mod10 = true;\n  const mod11 = checkMod11;\n  const isMod10 = ccMod10Check(value);\n  let isMod11 = false;\n\n  if (mod11) {\n    isMod11 = ccMod11Check(value);\n  }\n\n  const passesCheck =\n    mod10 && mod11\n      ? // either\n        isMod10 || isMod11\n      : // specific\n      mod10\n      ? isMod10\n      : isMod11;\n\n  return passesCheck;\n};\n","import acceptedBrandsCheck from './acceptedBrandsCheck';\nimport binCheck from './binCheck';\nimport { brands } from './brandBinMatrix';\nimport getRawValue from './getRawValue';\nimport checkMod from './modCheck';\nimport getPossibleBrand from './possibleBrand';\nimport { AMEX, LENGTH_AMEX, LENGTH_DEFAULT } from '../constants';\n\nexport default (maskedCardNumber, conditions = {}) => {\n  const {\n    cardBins = null,\n    checkMods = false,\n    partnerAcceptedBrands = brands,\n    shouldCheckAcceptedBrands = false,\n    validateMod11 = false\n  } = conditions;\n  const rawValue = getRawValue(maskedCardNumber);\n  const possibleBrand = getPossibleBrand(rawValue, cardBins);\n  const maxLength = possibleBrand === AMEX ? LENGTH_AMEX : LENGTH_DEFAULT;\n  const passesMod = checkMods\n    ? maskedCardNumber.length === maxLength && checkMod(maskedCardNumber, validateMod11)\n    : true;\n  const isSupportedBrand = shouldCheckAcceptedBrands\n    ? acceptedBrandsCheck(possibleBrand, partnerAcceptedBrands)\n    : true;\n  const isValidBin = binCheck(rawValue, cardBins);\n  const isValid = shouldCheckAcceptedBrands ? isSupportedBrand && isValidBin : isValidBin;\n\n  return {\n    brand: possibleBrand,\n    isSupported: isSupportedBrand,\n    isValid,\n    passesMod,\n    value: maskedCardNumber\n  };\n};\n","import { AMEX, AMEX_MASK, NON_AMEX_MASK } from '../constants';\n\nexport default brand => (brand === AMEX ? AMEX_MASK : NON_AMEX_MASK);\n","import { AMEX, ERROR_MAP, INVALID, LENGTH_AMEX, LENGTH_DEFAULT } from '../constants';\nimport checkMod from './modCheck';\n\nexport const validator = (isBlur, conditions = {}) => {\n  const {\n    brand,\n    checkMods = false,\n    checkMod11 = false,\n    isSupported = true,\n    isValid = true,\n    value\n  } = conditions;\n  const maxLength = brand === AMEX ? LENGTH_AMEX : LENGTH_DEFAULT;\n  const isPartialValue = value.length < maxLength;\n  let error;\n\n  /**\n   * `!value` means the field is empty (`ERROR_MAP.empty`)\n   * `!isSupported && brand !== INVALID` means entered value maps to a known card brand\n   but that brand is not supported by the partner or merchant. (`ERROR_MAP.not_supported`)\n   * `brand === INVALID` means the entered value does not map to a known card brand. (`ERROR_MAP.invalid_bin`)\n   * `!isValid` means the value maps to a known card brand but the value's bin is not valid for that card brand.\n   (`ERROR_MAP.invalid_bin_brand`)\n   * `!isPartialValue && checkMods && !checkMod(value, checkMod11)` is for when there is a full and complete\n   value for the card brand but the value does not pass mod checks, when mod checks are enabled. (`ERROR_MAP.invalid_generic`)\n   * `isPartialValue && isBlur` means that the entered value is a partial value for that card brand. (`ERROR_MAP.partial`)\n   */\n  if (!value) {\n    error = ERROR_MAP.empty;\n  } else if (!isSupported && brand !== INVALID) {\n    error = ERROR_MAP.not_supported;\n  } else if (brand === INVALID) {\n    error = ERROR_MAP.invalid_bin;\n  } else if (!isValid) {\n    error = ERROR_MAP.invalid_bin_brand;\n  } else if (!isPartialValue && checkMods && !checkMod(value, checkMod11)) {\n    error = ERROR_MAP.invalid_generic;\n  } else if (isPartialValue && isBlur) {\n    error = ERROR_MAP.partial;\n  }\n\n  return error;\n};\n","/* eslint-disable no-labels */\n\nimport { isArray, NO_MASK_ERROR, NO_PLACEHOLDER_CHAR_IN_MASK } from './index';\n\nconst emptyArray = [];\nconst emptyString = '';\n\n/**\n * This function returns an object with a property conformedValue (string).\n * It will also indicate if any characters were rejected\n *\n * @param {String} rawValue\n * @param {Array} mask\n * @param {Object} config\n * @return {{conformedValue: string, meta: {someCharsRejected: boolean}}}\n */\nexport default function conformToMask(rawValue = emptyString, mask, config = {}) {\n  // These configurations tell us how to conform the mask\n  const {\n    currentCaretPosition = 0,\n    guide = false,\n    placeholder = emptyString,\n    placeholderChars = emptyArray,\n    previousConformedValue = emptyString\n  } = config;\n\n  if (!isArray(mask)) {\n    throw new Error(NO_MASK_ERROR);\n  }\n\n  if (mask.filter(char => placeholderChars.includes(char)).length > 0) {\n    throw new Error(NO_PLACEHOLDER_CHAR_IN_MASK);\n  }\n\n  // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n  const suppressGuide = guide === false && previousConformedValue !== undefined;\n\n  const rawValueLength = rawValue.length;\n  const previousConformedValueLength = previousConformedValue.length;\n  const placeholderLength = placeholder.length;\n  const maskLength = mask.length;\n\n  // This tells us the number of edited characters and the direction in which they were edited (+/-)\n  const editDistance = rawValueLength - previousConformedValueLength;\n\n  // In *no guide* mode, we need to know if the user is trying to add a character or not\n  const isAddition = editDistance > 0;\n\n  // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n  const indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0);\n\n  // Convert rawValue to an array and track whether a character is new\n  const rawValueArr = rawValue.split(emptyString);\n\n  // Remove any placeholder characters from rawValueArr\n  for (let i = rawValueLength - 1; i >= 0; i--) {\n    const char = rawValueArr[i];\n\n    if (!placeholderChars.includes(char)) {\n      const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n\n      if (char === placeholder[shouldOffset ? i - editDistance : i]) {\n        rawValueArr.splice(i, 1);\n      }\n    }\n  }\n\n  // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n  let conformedValue = emptyString;\n  let someCharsRejected = false;\n\n  // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n  placeholderLoop: for (let i = 0; i < placeholderLength; i++) {\n    const charInPlaceholder = placeholder[i];\n\n    // We see one. Let's find out what we can put in it.\n    if (placeholderChars.includes(charInPlaceholder)) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          const rawValueChar = rawValueArr.shift();\n\n          if (rawValueChar === charInPlaceholder && suppressGuide !== true) {\n            conformedValue += charInPlaceholder;\n\n            // And we go to find the next placeholder character that needs filling\n            continue placeholderLoop;\n\n            // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (mask[i].test(rawValueChar)) {\n            conformedValue += rawValueChar;\n\n            // Since we've mapped this placeholder position. We move on to the next one.\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      }\n\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(i, placeholderLength);\n      }\n\n      break;\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  }\n\n  if (suppressGuide && isAddition === false) {\n    let indexOfLastFilledPlaceholderChar = null;\n\n    // Find the last filled placeholder position and substring from there\n    for (let i = 0; i < conformedValue.length; i++) {\n      if (placeholderChars.includes(placeholder[i])) {\n        indexOfLastFilledPlaceholderChar = i;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar === null) {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = emptyString;\n    } else {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    }\n  }\n\n  return { conformedValue, meta: { someCharsRejected } };\n}\n","/* eslint-disable no-lonely-if */\n\nconst emptyArray = [];\nconst emptyString = '';\n\n/**\n * Will return an integer representing the index of where the caret should be moved to next\n *\n * @param {String} conformedValue\n * @param {Number} currentCaretPosition\n * @param {Array} nonRegexChars\n * @param {String} placeholder\n * @param {Array} placeholderChars\n * @param {String} previousConformedValue\n * @param {String} previousPlaceholder\n * @param {String} rawValue\n * @return {Number}\n */\nexport default function adjustCaretPosition({\n  conformedValue = emptyString,\n  currentCaretPosition = 0,\n  nonRegexChars = emptyArray,\n  placeholder = emptyString,\n  placeholderChars = emptyArray,\n  previousConformedValue = emptyString,\n  previousPlaceholder = emptyString,\n  rawValue = emptyString\n}) {\n  if (currentCaretPosition === 0 || !rawValue.length) {\n    return 0;\n  }\n\n  const rawValueLength = rawValue.length;\n  const previousConformedValueLength = previousConformedValue.length;\n  const placeholderLength = placeholder.length;\n  const conformedValueLength = conformedValue.length;\n\n  const editLength = rawValueLength - previousConformedValueLength;\n\n  // If the edit length is positive, that means the user is adding characters, not deleting.\n  const isAddition = editLength > 0;\n\n  // This is the first raw value the user entered that needs to be conformed to mask\n  const isFirstRawValue = previousConformedValueLength === 0;\n\n  // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace. Such cases can also happen when the\n  // user presses the backspace while holding down the ALT key.\n  const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue;\n\n  if (isPartialMultiCharEdit) {\n    return currentCaretPosition;\n  }\n\n  // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\n  // same as the original `previousConformedValue`. We handle this case differently for caret\n  // positioning.\n  const possiblyHasRejectedChar =\n    isAddition && (previousConformedValue === conformedValue || conformedValue === placeholder);\n\n  let startingSearchIndex = 0;\n  let trackRightCharacter;\n  let targetChar;\n\n  if (possiblyHasRejectedChar) {\n    startingSearchIndex = currentCaretPosition - editLength;\n  } else {\n    const normalizedConformedValue = conformedValue.toLowerCase();\n    const normalizedRawValue = rawValue.toLowerCase();\n\n    // Then we take all characters that come before where the caret currently is.\n    const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString);\n\n    // Now we find all the characters in the left half that exist in the conformed input\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\n    const intersection = leftHalfChars.filter(\n      char => normalizedConformedValue.indexOf(char) !== -1\n    );\n\n    // The last character in the intersection is the character we want to look for in the conformed\n    // value and the one we want to adjust the caret close to\n    targetChar = intersection[intersection.length - 1];\n\n    // Calculate the number of mask characters in the previous placeholder\n    // from the start of the string up to the place where the caret is\n    const previousLeftMaskChars = previousPlaceholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter(char => !placeholderChars.includes(char)).length;\n\n    // Calculate the number of mask characters in the current placeholder\n    // from the start of the string up to the place where the caret is\n    const leftMaskChars = placeholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter(char => !placeholderChars.includes(char)).length;\n\n    // Has the number of mask characters up to the caret changed?\n    const maskLengthChanged = leftMaskChars !== previousLeftMaskChars;\n\n    // Detect if `targetChar` is a mask character and has moved to the left\n    const targetIsMaskMovingLeft =\n      previousPlaceholder[intersection.length - 1] !== undefined &&\n      placeholder[intersection.length - 2] !== undefined &&\n      !placeholderChars.includes(previousPlaceholder[intersection.length - 1]) &&\n      previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] &&\n      previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2];\n\n    // If deleting and the `targetChar` `is a mask character and `maskLengthChanged` is true\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\n    // if we are not at the end of the string.\n    // In this case, change tracking strategy and track the character to the right of the caret.\n    if (\n      !isAddition &&\n      (maskLengthChanged || targetIsMaskMovingLeft) &&\n      previousLeftMaskChars > 0 &&\n      placeholder.indexOf(targetChar) > -1 &&\n      rawValue[currentCaretPosition] !== undefined\n    ) {\n      trackRightCharacter = true;\n      targetChar = rawValue[currentCaretPosition];\n    }\n\n    // We need to know how many times it occurs in the intersection\n    const countTargetCharInIntersection = intersection.filter(char => char === targetChar).length;\n\n    // We need to know if the placeholder contains characters that look like\n    // our `targetChar`, so we don't select one of those by mistake.\n    const countTargetCharInPlaceholder = placeholder\n      .split(emptyString)\n      .filter(\n        (char, index) =>\n          !nonRegexChars.includes(char) && char === targetChar && rawValue[index] !== char\n      ).length;\n\n    // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking for is:\n    const requiredNumberOfMatches =\n      countTargetCharInPlaceholder +\n      countTargetCharInIntersection +\n      // The character to the right of the caret isn't included in `intersection`\n      // so add one if we are tracking the character to the right\n      (trackRightCharacter ? 1 : 0);\n\n    // Now we start looking for the location of the `targetChar`.\n    // We keep looping forward and store the index in every iteration. Once we have encountered\n    // enough occurrences of the target character, we break out of the loop\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\n    let numberOfEncounteredMatches = 0;\n    for (let i = 0; i < conformedValueLength; i++) {\n      const conformedValueChar = normalizedConformedValue[i];\n\n      startingSearchIndex = i + 1;\n\n      if (conformedValueChar === targetChar) {\n        numberOfEncounteredMatches++;\n      }\n\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n        break;\n      }\n    }\n  }\n\n  // In case of addition, we fast forward.\n  if (isAddition) {\n    // We want to remember the last placeholder character encountered so that if the mask\n    // contains more characters after the last placeholder character, we don't forward the caret\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\n    let lastPlaceholderChar = startingSearchIndex;\n\n    for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n      if (placeholderChars.includes(placeholder[i])) {\n        lastPlaceholderChar = i;\n      }\n\n      if (placeholderChars.includes(placeholder[i]) || i === placeholderLength) {\n        return lastPlaceholderChar;\n      }\n    }\n  } else {\n    // In case of deletion, we rewind.\n    if (trackRightCharacter) {\n      // Searching for the character that was to the right of the caret\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\n      for (let i = startingSearchIndex - 1; i >= 0; i--) {\n        if (conformedValue[i] === targetChar || i === 0) {\n          return i;\n        }\n      }\n    } else {\n      // Searching for the first placeholder or caret trap to the left\n      for (let i = startingSearchIndex; i >= 0; i--) {\n        if (placeholderChars.includes(placeholder[i - 1]) || i === 0) {\n          return i;\n        }\n      }\n    }\n  }\n\n  return -1;\n}\n","import {\n  adjustCaretPosition,\n  conformToMask,\n  cleanMask,\n  safeSetSelection,\n  isHTMLInputElement,\n  isNil,\n  NO_INPUT_ERROR\n} from './index';\n\n/**\n * This function takes a configuration and returns an object with an update method.\n * The update method is used to conform the raw value to the mask you provide in the config\n *\n * @param {Object} config\n * @return {{state: Object, update: Function}}\n */\nexport default function createTextMaskInputElement(config = {}) {\n  const state = {\n    previousConformedValue: undefined,\n    previousPlaceholder: undefined\n  };\n\n  return {\n    state,\n\n    update(\n      rawValue,\n      { guide = false, inputElement, mask, placeholderChar = 'X', upperCaseValue = false } = config\n    ) {\n      if (!isHTMLInputElement(inputElement)) {\n        throw new Error(NO_INPUT_ERROR);\n      }\n\n      const { selectionEnd: currentCaretPosition, value: inputValue } = inputElement;\n\n      if (isNil(rawValue)) {\n        rawValue = inputValue;\n      } else {\n        rawValue = rawValue.toString();\n      }\n\n      const { mask: cleanedMask, placeholder, nonRegexChars, placeholderChars } = cleanMask(\n        mask,\n        placeholderChar\n      );\n\n      if (rawValue === state.previousConformedValue && placeholder === state.previousPlaceholder) {\n        return {\n          ...state,\n          adjustedCaretPosition: currentCaretPosition,\n          conformedValue: rawValue\n        };\n      }\n\n      const { conformedValue } = conformToMask(rawValue, cleanedMask, {\n        currentCaretPosition,\n        guide,\n        placeholder,\n        placeholderChars,\n        previousConformedValue: state.previousConformedValue\n      });\n\n      const adjustedCaretPosition = adjustCaretPosition({\n        conformedValue,\n        currentCaretPosition,\n        nonRegexChars,\n        placeholder,\n        placeholderChars,\n        previousConformedValue: state.previousConformedValue,\n        previousPlaceholder: state.previousPlaceholder,\n        rawValue\n      });\n\n      // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n      const inputValueShouldBeEmpty = conformedValue === placeholder && adjustedCaretPosition === 0;\n      const inputElementValue = inputValueShouldBeEmpty\n        ? ''\n        : upperCaseValue\n        ? conformedValue.toUpperCase()\n        : conformedValue;\n\n      state.previousConformedValue = inputElementValue;\n      state.previousPlaceholder = placeholder;\n\n      inputElement.value = inputElementValue;\n      safeSetSelection(inputElement, adjustedCaretPosition);\n\n      return {\n        ...state,\n        adjustedCaretPosition,\n        conformedValue: inputElementValue\n      };\n    }\n  };\n}\n","import { NO_MASK_ERROR } from './index';\n\nconst isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\nconst defer = typeof requestAnimationFrame === 'undefined' ? setTimeout : requestAnimationFrame;\n\n/**\n * Set cursor position on an input element\n * @param {HTMLElement} element\n * @param {Number} selectionPosition\n */\nexport function safeSetSelection(element, selectionPosition) {\n  if (document.activeElement === element) {\n    if (isAndroid) {\n      defer(() => element.setSelectionRange(selectionPosition, selectionPosition, 'none'), 0);\n    } else {\n      element.setSelectionRange(selectionPosition, selectionPosition, 'none');\n    }\n  }\n}\n\n/**\n * Tells you whether a value is a string\n * @param {String} value\n * @return {Boolean}\n */\nexport function isString(value) {\n  return typeof value === 'string' || value instanceof String;\n}\n\n/**\n * Tells you whether a value is a array\n * @param {String} value\n * @return {Boolean}\n */\nexport function isArray(value) {\n  return (Array.isArray && Array.isArray(value)) || value instanceof Array;\n}\n\n/**\n * Tells you whether a value is nil\n * @param {String} value\n * @return {Boolean}\n */\nexport function isNil(value) {\n  return typeof value === 'undefined' || value === null;\n}\n\n/**\n * Tells you whether an element is an input type\n * @param {HTMLElement} element\n * @return {Boolean}\n */\nexport function isHTMLInputElement(element) {\n  return (\n    (element instanceof Element || element instanceof HTMLDocument) &&\n    element.nodeType === 1 &&\n    element.tagName.toLowerCase() === 'input'\n  );\n}\n\n/**\n * Tells you whether a value is a string and has a length > 0\n * @param {String} value\n * @return {Boolean}\n */\nexport function validString(value) {\n  return isString(value) && value.length > 0;\n}\n\n/**\n * Returns the display name of a component\n * @param {Component} WrappedComponent\n * @return {string | * | string}\n */\nexport function getComponentDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\n/**\n * Returns an object containing all the info needed for Text-Mask library\n * @param {Array} mask\n * @param {String} placeholderChar\n * @return {{mask: [], nonRegexChars: [], placeholder: string, placeholderChars: []}}\n */\nexport function cleanMask(mask, placeholderChar = 'X') {\n  if (!isArray(mask)) {\n    throw new Error(NO_MASK_ERROR);\n  }\n\n  const cleanedMask = mask.reduce(\n    (maskObj, char) => {\n      const { mask, placeholderChars, placeholder } = maskObj;\n      const maskChar = char && char.mask instanceof RegExp ? char.mask : char;\n      const placeChar =\n        char && typeof char.placeholder === 'string' ? char.placeholder.charAt(0) : placeholderChar;\n\n      mask.push(typeof maskChar === 'string' ? maskChar.charAt(0) : maskChar);\n\n      placeholder.push(\n        char instanceof RegExp || char.mask instanceof RegExp\n          ? placeChar\n          : char.toString().charAt(0)\n      );\n\n      if (!placeholderChars.includes(placeChar)) {\n        placeholderChars.push(placeChar);\n      }\n\n      return maskObj;\n    },\n    {\n      mask: [],\n      placeholder: [],\n      placeholderChars: []\n    }\n  );\n\n  // Filter out empty string\n  const cleanMask = cleanedMask.mask.filter(Boolean);\n  // Create placeholder string representation\n  const placeholderStr = cleanedMask.placeholder.join('');\n  // Remove any duplicates from placeholder array and filter out empty string\n  const nonRegexChars = [...new Set(cleanedMask.placeholder.filter(Boolean))];\n  // Only use placeholder chars present in nonRegexChars array\n  let placeholderChars = cleanedMask.placeholderChars.filter(char => nonRegexChars.includes(char));\n  // If our `placeholderChars` array is empty, default to using `placeholderChar`\n  if (placeholderChars.length === 0) {\n    placeholderChars = [placeholderChar];\n  }\n\n  return {\n    mask: cleanMask,\n    nonRegexChars,\n    placeholder: placeholderStr,\n    placeholderChars\n  };\n}\n","export const NO_MASK_ERROR = `An array containing a valid mask is required. Please refer to LINK_WIKI for more information`;\nexport const NO_INPUT_ERROR = `An input element is required to enable Masking. Please refer to LINK_WIKI for more information`;\nexport const NO_PLACEHOLDER_CHAR_IN_MASK =\n  'A placeholder character must not be used as part of the mask. ' +\n  'Please specify a character that is not present in your mask as your placeholder character.';\n","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","import { useRef, useState, useEffect } from 'react';\nimport {\n  NO_INPUT_ERROR,\n  NO_MASK_ERROR,\n  createTextMaskInputElement,\n  isArray,\n  isNil\n} from '../index';\n\n/**\n * Custom hook to give an input element Text-Masking capabilities\n * This component will default w/ the empty string as the `value setting\n * @param {Object} props\n * @return {Object} shape is as follows...\n * {\n *    getInputProps: {\n *      onChange: Function,\n *      ref: Object,\n *      value: String -- Defaults to empty string. This may set any `controlled` boolean flags to TRUE (e.g. props.value !== undefined)\n *    },\n *    meta: {\n *      adjustedCaretPosition: (undefined|Number),\n *      placeholder: String\n *    }\n * }\n */\nexport default function useTextMask(props = {}) {\n  const {\n    guide = false,\n    mask,\n    onChange,\n    placeholderChar = 'X',\n    upperCaseValue = false,\n    value\n  } = props;\n\n  const inputRef = useRef(null);\n  const textMask = useRef(null);\n  const [state, setState] = useState({\n    adjustedCaretPosition: undefined,\n    conformedValue: isNil(value) ? '' : value.toString(),\n    placeholder: undefined\n  });\n\n  const createTextMask = () =>\n    createTextMaskInputElement({\n      guide,\n      inputElement: inputRef.current,\n      mask,\n      placeholderChar,\n      upperCaseValue\n    });\n\n  useEffect(() => {\n    textMask.current = createTextMask();\n    const {\n      adjustedCaretPosition,\n      conformedValue,\n      previousPlaceholder: placeholder\n    } = textMask.current.update();\n    setState({ adjustedCaretPosition, conformedValue, placeholder });\n  }, [guide, mask, placeholderChar]);\n\n  useEffect(() => {\n    if (textMask.current) {\n      const {\n        adjustedCaretPosition,\n        conformedValue,\n        previousPlaceholder: placeholder\n      } = textMask.current.update(value);\n      setState({ adjustedCaretPosition, conformedValue, placeholder });\n    }\n  }, [value]);\n\n  useEffect(() => {\n    if (inputRef.current) {\n      if (isArray(mask) && mask.length > 0) {\n        textMask.current = createTextMask();\n        const {\n          adjustedCaretPosition,\n          conformedValue,\n          previousPlaceholder: placeholder\n        } = textMask.current.update(value);\n        setState({ adjustedCaretPosition, conformedValue, placeholder });\n      } else {\n        throw new Error(NO_MASK_ERROR);\n      }\n    } else {\n      throw new Error(NO_INPUT_ERROR);\n    }\n  }, []);\n\n  /**\n   * @param {Event} e\n   * @protected\n   */\n  function handleChange(e) {\n    const {\n      adjustedCaretPosition,\n      conformedValue,\n      previousPlaceholder: placeholder\n    } = textMask.current.update();\n\n    const newState = {\n      adjustedCaretPosition,\n      conformedValue,\n      placeholder\n    };\n\n    setState(newState);\n\n    typeof onChange === 'function' && onChange(e, newState);\n  }\n\n  return {\n    getInputProps: {\n      onChange: handleChange,\n      ref: inputRef,\n      value: state.conformedValue\n    },\n    meta: {\n      adjustedCaretPosition: state.adjustedCaretPosition,\n      placeholder: state.placeholder\n    }\n  };\n}\n\n/**\n * Render Prop implemention using our custom hook\n * @constructor\n */\nexport function TextMaskInput({ children, ...props }) {\n  return children(useTextMask(props));\n}\n"],"sourceRoot":""}